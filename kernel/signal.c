#include "signal.h"
#include "types.h"
#include "debug.h"
#include "string.h"
#include "process.h"
#include "paging.h"
#include "scheduler.h"
#include "x86_desc.h"
#include "syscall.h"

/*
 * Pushes the signal handler context onto the user stack
 * and modifies the register context to start execution
 * at the signal handler.
 */
static bool
signal_deliver(signal_info_t *sig, int_regs_t *regs)
{
    /* "Shellcode" that calls the sigreturn() syscall */
    uint8_t shellcode[] = {
        /* movl $SYS_SIGRETURN, %eax */
        0xB8, 0x00, 0x00, 0x00, 0x00,

        /* movl signum, %ebx */
        0xBB, 0x00, 0x00, 0x00, 0x00,

        /* movl regs, %ecx */
        0xB9, 0x00, 0x00, 0x00, 0x00,

        /* int 0x80 */
        0xCD, 0x80,

        /* nop (to align stack to 4 bytes) */
        0x90, 0x90, 0x90,
    };

    /* Make sure shellcode is 4-byte aligned for stack */
    assert((sizeof(shellcode) & 0x3) == 0);

    /* Two-step copy: first copy to buffer, then copy buffer to userspace */
    uint8_t buf[
        sizeof(shellcode) +  /* shellcode */
        sizeof(int_regs_t) + /* regs */
        sizeof(int) +        /* signum */
        sizeof(uint32_t)];   /* return address */
    uint8_t *bufp = buf + sizeof(buf);
    uint8_t *esp = (uint8_t *)regs->esp;

    /* No way we can fit this onto the user stack, abort! */
    if ((uint32_t)esp < sizeof(buf)) {
        return false;
    }

    /* Push sigreturn linkage onto user stack */
    bufp -= sizeof(shellcode);
    esp -= sizeof(shellcode);
    memcpy(bufp, shellcode, sizeof(shellcode));
    uint8_t *shellcode_addr = esp;
    uint8_t *shellcode_bufp = bufp;

    /* Push interrupt context onto user stack */
    bufp -= sizeof(int_regs_t);
    esp -= sizeof(int_regs_t);
    memcpy(bufp, regs, sizeof(int_regs_t));
    uint8_t *intregs_addr = esp;

    /* Push signal number onto user stack */
    bufp -= sizeof(int);
    esp -= sizeof(int);
    memcpy(bufp, &sig->signum, sizeof(int));

    /* Push return address (which is sigreturn linkage) onto user stack */
    bufp -= sizeof(uint32_t);
    esp -= sizeof(uint32_t);
    memcpy(bufp, &shellcode_addr, sizeof(uint32_t));

    /* Fill in shellcode values */
    int syscall_num = SYS_SIGRETURN;
    memcpy(shellcode_bufp + 1, &syscall_num, 4);
    memcpy(shellcode_bufp + 6, &sig->signum, 4);
    memcpy(shellcode_bufp + 11, &intregs_addr, 4);

    /* Copy everything into userspace */
    assert(bufp == buf);
    if (!copy_to_user(esp, bufp, sizeof(buf))) {
        return false;
    }

    /* Change EIP of userspace program to the signal handler */
    regs->eip = (uint32_t)sig->handler_addr;

    /* Change ESP to point to new stack bottom */
    regs->esp = (uint32_t)esp;

    /* Fix segment registers in case that was the cause of an exception */
    regs->cs = USER_CS;
    regs->ds = USER_DS;
    regs->es = USER_DS;
    regs->fs = USER_DS;
    regs->gs = USER_DS;
    regs->ss = USER_DS;

    /* Clear direction flag */
    regs->eflags &= ~EFLAGS_DF;

    /* Mask signal so we don't get re-entrant calls */
    sig->masked = true;
    sig->pending = false;
    return true;
}

/*
 * sigaction() syscall handler. Sets the signal handler to be
 * used to handle the specified signal.
 */
__cdecl int
signal_sigaction(int signum, void (*handler_address)(int))
{
    /* Check signal number range */
    if (signum < 0 || signum >= NUM_SIGNALS || signum == SIGKILL) {
        return -1;
    }

    pcb_t *pcb = get_executing_pcb();
    pcb->signals[signum].handler_addr = handler_address;
    return 0;
}

/*
 * sigreturn() syscall handler. This should never be called
 * directly by a user program; calls to it are generated by
 * the kernel signal delivery code.
 */
__cdecl int
signal_sigreturn(
    int signum,
    int_regs_t *user_regs,
    intptr_t unused1,
    intptr_t unused2,
    intptr_t unused3,
    int_regs_t *kernel_regs)
{
    /* Check signal number range */
    if (signum < 0 || signum >= NUM_SIGNALS || signum == SIGKILL) {
        debugf("Invalid signal number\n");
        return -1;
    }

    /* First copy to a temporary context... */
    int_regs_t tmp_regs;
    if (!copy_from_user(&tmp_regs, user_regs, sizeof(int_regs_t))) {
        debugf("Cannot read user regs\n");
        return -1;
    }

    /* Unmask signal again */
    pcb_t *pcb = get_executing_pcb();
    pcb->signals[signum].masked = false;

    /* Ignore privileged EFLAGS bits (emulate POPFL behavior) */
    /* http://stackoverflow.com/a/39195843 */
    uint32_t kernel_eflags = kernel_regs->eflags & ~EFLAGS_USER;
    uint32_t user_eflags = tmp_regs.eflags & EFLAGS_USER;
    tmp_regs.eflags = kernel_eflags | user_eflags;

    /* Reset segment registers (no privilege exploits for you!) */
    tmp_regs.cs = USER_CS;
    tmp_regs.ds = USER_DS;
    tmp_regs.es = USER_DS;
    tmp_regs.fs = USER_DS;
    tmp_regs.gs = USER_DS;
    tmp_regs.ss = USER_DS;

    /* Copy temporary context to kernel context */
    *kernel_regs = tmp_regs;

    /*
     * Interrupt handler overwrites EAX with the return value,
     * so we just return EAX so it will get set to itself.
     */
    return kernel_regs->eax;
}

/*
 * sigmask() syscall handler. Blocks, unblocks, or checks the
 * blocked status of a signal. If action is SIGMASK_BLOCK, the
 * signal is blocked. If action is SIGMASK_UNBLOCK, the signal
 * is unblocked. SIGMASK_NONE is a no-op. In all cases, the
 * original blocked status is returned.
 */
__cdecl int
signal_sigmask(int signum, int action)
{
    if (signum < 0 || signum >= NUM_SIGNALS || signum == SIGKILL) {
        return -1;
    }

    pcb_t *pcb = get_executing_pcb();
    signal_info_t *sig = &pcb->signals[signum];
    int orig_masked = sig->masked ? SIGMASK_BLOCK : SIGMASK_UNBLOCK;
    switch (action) {
    case SIGMASK_NONE:
        break;
    case SIGMASK_BLOCK:
        sig->masked = true;
        break;
    case SIGMASK_UNBLOCK:
        sig->masked = false;
        break;
    default:
        return -1;
    }
    return orig_masked;
}

/*
 * Marks a signal as pending for the given process, and
 * wakes it if it's sleeping and the signal needs to be
 * delivered.
 */
static void
signal_raise(pcb_t *pcb, int signum)
{
    if (pcb->signals[signum].handler_addr != SIG_IGN) {
        pcb->signals[signum].pending = true;
        if (signal_has_pending(pcb->signals)) {
            scheduler_wake(pcb);
        }
    }
}

/*
 * Raises a signal for a single process.
 */
static int
signal_kill_one(int pid, int signum)
{
    pcb_t *pcb = get_pcb(pid);
    if (pcb == NULL || pcb->state == PROCESS_STATE_ZOMBIE) {
        return -1;
    }

    signal_raise(pcb, signum);
    return 0;
}

/*
 * Raises a signal for every process in the specified
 * process group. Returns 0 if there was at least one
 * process in that group.
 */
static int
signal_kill_group(int pgid, int signum)
{
    int ret = -1;
    pcb_t *pcb;
    process_for_each(pcb) {
        if (pcb->group == pgid) {
            ret = 0;
            signal_raise(pcb, signum);
        }
    }
    return ret;
}

/*
 * kill() syscall handler. If pid > 0, sends a signal specified by
 * signum to the specified process. If pid < 0, sends the signal
 * to every process in the process group with pgid == -pid. If
 * pid == 0, sends the signal to every process in the calling
 * process's group.
 */
__cdecl int
signal_kill(int pid, int signum)
{
    if (signum < 0 || signum >= NUM_SIGNALS) {
        return -1;
    }

    if (pid > 0) {
        return signal_kill_one(pid, signum);
    } else if (pid < 0) {
        return signal_kill_group(-pid, signum);
    } else {
        return signal_kill_group(get_executing_pcb()->group, signum);
    }
}

/*
 * Attempts to deliver a signal to the currently
 * executing process. Returns true if the signal
 * was actually delivered or the process was
 * killed, and false if the signal was ignored.
 */
static bool
signal_handle(signal_info_t *sig, int_regs_t *regs)
{
    /* Kill signal should be handled entirely by kernel */
    if (sig->signum == SIGKILL) {
        debugf("Killing process due to SIGKILL\n");
        process_halt_impl(128 + sig->signum);
        return true;
    }

    /* If signal is masked, keep it pending but skip over it */
    if (sig->masked) {
        return false;
    }

    /* If user asked to ignore the signal, clear it immediately */
    if (sig->handler_addr == SIG_IGN) {
        sig->pending = false;
        return false;
    }

    /* If a handler is explicitly set, run it */
    if (sig->handler_addr != SIG_DFL) {
        if (!signal_deliver(sig, regs)) {
            /* If no more space on stack to push signal context, kill process */
            debugf("Failed to push signal context, killing process\n");
            process_halt_impl(256);
        }

        return true;
    }

    /* These should halt with a status of 256 according to the spec */
    if (sig->signum == SIGFPE ||
        sig->signum == SIGSEGV)
    {
        debugf("Killing process due to exception\n");
        process_halt_impl(256);
        return true;
    }

    /* Halt with appropriate code if default action is to kill process */
    if (sig->signum == SIGINT ||
        sig->signum == SIGPIPE ||
        sig->signum == SIGABRT)
    {
        debugf("Killing process by default action\n");
        process_halt_impl(128 + sig->signum);
        return true;
    }

    /* All other signals should be ignored by default */
    sig->pending = false;
    return false;
}

/*
 * Initializes the signal state for a proces.
 */
void
signal_init(signal_info_t *signals)
{
    int i;
    for (i = 0; i < NUM_SIGNALS; ++i) {
        signal_info_t *sig = &signals[i];
        sig->signum = i;
        sig->handler_addr = SIG_DFL;
        sig->masked = false;
        sig->pending = false;
    }
}

/*
 * Clones the signal state for a new process. Note that pending
 * signals are not preserved.
 */
void
signal_clone(signal_info_t *dest, signal_info_t *src)
{
    int i;
    for (i = 0; i < NUM_SIGNALS; ++i) {
        signal_info_t *di = &dest[i];
        signal_info_t *si = &src[i];
        di->signum = si->signum;
        di->handler_addr = si->handler_addr;
        di->masked = si->masked;
        di->pending = false;
    }
}

/*
 * If a process has any pending signals, modifies its interrupt
 * context and user stack to run the signal handler. regs must
 * point to the process's interrupt context on the stack.
 */
void
signal_handle_all(signal_info_t *signals, int_regs_t *regs)
{
    int i;
    for (i = 0; i < NUM_SIGNALS; ++i) {
        signal_info_t *sig = &signals[i];
        if (sig->pending && signal_handle(sig, regs)) {
            break;
        }
    }
}

/*
 * Returns whether a process has a pending signal for which
 * there exists a handler (or default action) that does something.
 * This is used to abort long-running wait loops with -EINTR.
 */
bool
signal_has_pending(signal_info_t *signals)
{
    int i;
    for (i = 0; i < NUM_SIGNALS; ++i) {
        signal_info_t *sig = &signals[i];

        if (sig->pending) {
            /* SIGKILL must always be handled */
            if (sig->signum == SIGKILL) {
                return true;
            }

            /* If signal is ignored or masked, skip over it */
            if (sig->handler_addr == SIG_IGN || sig->masked) {
                continue;
            }

            /*
             * If user registered a handler and the signal is not
             * masked, then we always execute it.
             */
            if (sig->handler_addr != SIG_DFL) {
                return true;
            }

            /*
             * If there's no manually registered handler, check
             * if default action actually does something. Here we
             * ignore whether the signal is masked since all our
             * default actions kill the process.
             */
            switch (sig->signum) {
            case SIGFPE:
            case SIGSEGV:
            case SIGINT:
            case SIGKILL:
            case SIGPIPE:
            case SIGABRT:
                return true;
            }
        }
    }
    return false;
}

/*
 * Raises a signal for the executing process.
 */
void
signal_raise_executing(int signum)
{
    signal_raise(get_executing_pcb(), signum);
}
